---
uip: 0107
title: Auras Renovation
description: Address inconsistencies in the aura type system
author: ~ponmep-litsem
status: Draft
type: Standards Track
category: Hoon
created: 2023-06-30
---

## Abstract

The aura type system provides a way to indicate a particular interperation of an atom in Hoon. An aura of an atom influences both how it is presented to the user, as well as specifies the parsing routine. Currently, auras are used in an inconsistent manner, thus preventing enforcement of atom sanity at the compiler level. In this proposal, we address these inconsistencies, together with related problems. With the implementation of this proposal, auras become a correct type system tool, dispensing with the need for manual atom sanity checks.

## Motivation

There are several ways in which auras are used in an inconsistent manner.

1. The `aura` type itself, defined as `@ta`, violates the constraint on knots, which do not permit uppercase letters.

2. Use of a `term`, which is too restrictive, for an aura variable, which admits uppercase bit-width indicator.
	An example of this inconsistency is in the Hoon atom definition,
	
	```
	+$  hoon
	...
	[%rock p=term q=*]
	[%sand p=term q=*]
	```
as well as in many functions throughout `sys/hoon.hoon` which accept `term` for an `aura`. This is seen in 		practice 	with tapes, defined as `(list @tD)`. Another example is `+fitz` which accepts a `term` for a general aura.

3. Further, there are two Hoon literals which have uppercase letters in their digit set: `@uc` and `@uw`. The `scot` atom printer returns a `@ta`, and the `slaw` family of atom parsers similarly violates this same constraint, accepting a `@ta` as their string argument.

4. The `+slaw` family of atom parsers accepts a `@tas` for an aura, thus restricting valid auras with bit-width indicator.

5. Clay persists invalid paths according to the path specification as a list of `@ta`. These can either be some valid `@uc`, `@uw` atoms, or, more generally, any path addressing a file whose name contains uppercase letters.

These violations of the aura type system make it impossible to enforce sanity of atoms at the compiler level, as originally envisioned with the `+sane` and `+ruth` arms and had caused problems in `%clay` handling 
of paths. Fixing the aura type system, as proposed here, is a required step before enabling compiler
atom sanity checks in the future. 

Apart from the inconsistent use of the auras, there are also two related problems:

- (A) `+sane`, so far not used at the compiler level, is under-specified and performs only some atom sanity checks
- (B) Default hexadecimal printing of user-defined auras could become a source of unforseen bugs should this behaviour be changed in the future

## Specification
- The knot aura `@ta` denotes a string composed of allowed characters: `[0-9], [a-z], [A-Z], cab, hep, sig, dot`. It is considered URL-safe, and allows the encoding of all Hoon constants.
- Aura syntax. A valid aura consists of three parts, prefixed by `@`: the major part, the bit-width (optional), and the minor part (optional). The major part is matched by `[a-z]*`. The bit-width is matched by `[A-Z]`. The minor part is matched by `-[a-z]+`. Examples of valid auras include `@u`, `@uD`, `@uv-blob`, `@uxG-hash`.
- Aura nesting rules. Aura B nests in aura A if the following conditions are all satisfied. (1) Nesting in the major part. B nests in A if the major part of B is an extension of the major part of A. (2) Nesting in the bit-width. B nests in A if the bit-width of B is not greater than the bit-width of A. Absence of bit-width indicates unlimited size. (3) Nesting in the minor part. B nests in A if the minor part of B matches the minor part of A.
- Aura _compatibility_. Auras `A` and `B` are said to be compatible if and only if A nests in B or B nests in A.
- (To be determined) The `@t` aura denotes a UTF-8 string composed of such and such characters.
- (To be determined) The `@c` aura denotes a UTF-32 string composed of such and such characters.
- Auras are printed by the `+scot` arm. The pretty-printer renders user-defined auras according their
 nearest defined nest aura.

## Rationale

### `@ta` to allow uppercase letters

The exclusion of uppercase letters from the knot aura `@ta` specification seems unnecessary. Relaxation of this condition alone solves problems 1â€“5. There seems to be little justification for it at present, beyond enforcing strict URL safety. It is clear that such strictness can no longer be maintained.

Hoon literals can not be considered URL-safe unless uppercase letters are permitted. Overwhelming majority of websites is served by UNIX systems, which are naturally case sensitive. Clay too has to allow uppercase filenames.

We therefore propose to relax this restriction and allow uppercase letters in `@ta`, declaring it to be URL-safe.

### New aura syntax and nesting rules

#### Major part nests only by extension.

The nesting rules for the major part are modified. Previously, the nesting rules functioned as a bidirectional compatibility check. The aura `@tas` nests in `@ta`, and `@ta` nests in `@tas`. The latter could easily result in production of mad atoms, since an aura extension could introduce a constraint not present in its parent.

#### Bit-width syntax with alternative nesting behaviour

Currently, only the last uppercase letter is treated as a bit-width extension by the aura compatibility check arm `+fitz`. This means that an aura like `@uDE` denotes an aura of type `@uD` with the bit-width extension of `E` -- 16 bits. We propose to simplify things by further restricting the bit-width syntax: only a single, trailing uppercase letter is allowed in the aura specification. Thus  an aura `@uDE` is invalid, while `@uD` and `@uE` are allowed.

#### Minor part nests by exact match

The minor part of an aura allows us to introduce more descriptive aura types, to state the indented purpose of the aura, in addition to its semantics. For instance, `@uxD-flag` could be used when communicating with hardware devices, while `@uv-blob` could be used in place of the less readable `@uvblob`. The minor part nests based on exact match, as opposed to the major part, which nests by extension. In particular, `@uv-blob` does not nest under `@uv`, and the _universal aura_ `@` is not compatible with any aura with a minor extension. 

### Example parser of the new syntax

An example implementation of the new `+mota` to be introduced by this proposal is presented below.

```
|=  a=tape
=<
(scan a mota)
|%
++  mota  ;~(pfix pat ;~(plug major (punt bit-width) (punt minor)))
++  major  (star low)
++  bit-width  hig
++  minor  ;~(plug hep (plus low))
--
```

### Change in default printing of atoms

The default printing of user-defined auras as hexadecimal number without separators tempts the programmer to exploit this behaviour as a convenient way to print atoms. It is also inconsistent with the rendering of the empty aura `@` as an unsigned decimal atom. Rather, user-defined auras should render in the same way as the `@` aura, under which they nest.

## Backward Compatibility

- The stricter aura syntax, with only single trailing uppercase bit-width annotation allowed, is currently obeyed across all standard desks.
- The redefined `@ta` aura will cover a wider range of strings and is therefore backward-compatible.
- With the change of default printing of user-defined auras, any code relying on it will malfunction.

## Acknowledgements 

~rovnys-ricfer proposed extending the aura syntax with minor part. 

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).